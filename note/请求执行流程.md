#WEB请求的执行流程

---------------------------
##大循环

- `yii\web\Application($config)`
- `yii\base\Application($config)::run()`

在`run()`方法内部有如下代码：

```php
try {

    $this->state = self::STATE_BEFORE_REQUEST;
    $this->trigger(self::EVENT_BEFORE_REQUEST);

    $this->state = self::STATE_HANDLING_REQUEST;
    // 获得请求句柄 为响应组织内容
    $response = $this->handleRequest($this->getRequest());

    $this->state = self::STATE_AFTER_REQUEST;
    $this->trigger(self::EVENT_AFTER_REQUEST);

    $this->state = self::STATE_SENDING_RESPONSE;
    // 发送响应
    $response->send();

    $this->state = self::STATE_END;

    return $response->exitStatus;

} catch (ExitException $e) {

    $this->end($e->statusCode, isset($response) ? $response : null);
    return $e->statusCode;

}
```
- 其中`$this->handleRequest($this->getRequest());`语句是处理请求的核心。

----------------------------------------------------------
##`yii\base\Application::handleRequest()`中的小循环：

- `yii\base\Application::handleRequest()`为抽象方法，调用子类方法
- `yii\web\Application::handleRequest()`中主要代码如下：

```php
try {
    Yii::trace("Route requested: '$route'", __METHOD__);
    $this->requestedRoute = $route;
    $result = $this->runAction($route, $params);
    if ($result instanceof Response) {
        return $result;
    } else {
        $response = $this->getResponse();
        if ($result !== null) {
            $response->data = $result;
        }

        return $response;
    }
} catch (InvalidRouteException $e) {
    throw new NotFoundHttpException(Yii::t('yii', 'Page not found.'), $e->getCode(), $e);
}
```

- 有继承关系：`yii\web\Application -> yii\base\Application -> yii\base\Module -> yii\di\ServiceLocator -> yii\base\Component -> yii\base\Object`   
- 其中`yii\web\Application::handleRequest()`调用`$this->runAction($route, $params)`为父类`yii\base\Module::runAction()`方法，该方法代码如下：

```php
public function runAction($route, $params = [])
{
    //调用本类的createController()方法创建控制器对象
    $parts = $this->createController($route);
    if (is_array($parts)) {
        /* @var $controller Controller */
        // 控制器实例化成功了，那就交给控制器的$controller->runAction()方法实例化动作
        list($controller, $actionID) = $parts;
        $oldController = Yii::$app->controller;
        Yii::$app->controller = $controller;
        $result = $controller->runAction($actionID, $params);
        Yii::$app->controller = $oldController;

        return $result;
    } else {
        $id = $this->getUniqueId();
        throw new InvalidRouteException('Unable to resolve the request "' . ($id === '' ? $route : $id . '/' . $route) . '".');
    }
}
```    

- `yii\base\Module::runAction()`方法实例化相应的控制器类后，会执行相应控制器的`$controller->runAction($actionID, $params)`方法。`yii\base\Controller::runAction()`方法的源代码摘要如下：

```php
/*
 * 获取所有父类的module，依次调用他们的beforeAction
 * 【获取当前控制器的所以的模块，并执行每个模块的beforeAction来检查当前的action是否可以执行，
 * 注意：getModules返回的数组顺序为：从父模块到子模块，
 * 所以在执行beforeAction的时候，先检查最外层的父模块，然后检查子模块。
 *
 * 然而在执行afterAction的时候，顺序就反过来了，先执行子模块，最后执行父模块。】
 */
foreach ($this->getModules() as $module) {
    if ($module->beforeAction($action)) {
        array_unshift($modules, $module);
    } else {
        $runAction = false;
        break;
    }
}

$result = null;

/**
 * 如果$runAction 始终标记为true且当前控制器的
 * beforeAction($action)也通过，则执行action
 */
if ($runAction && $this->beforeAction($action)) {
    // run the action
    $result = $action->runWithParams($params);

    $result = $this->afterAction($action, $result);

    // call afterAction on modules
    foreach ($modules as $module) {
        /* @var $module Module */
        $result = $module->afterAction($action, $result);
    }
}

```
    
- 可见`yii\base\Controller::runAction()`方法在执行动作之前执行了当前控制器对象的`beforeAction()`方法，该方法源代码如下：

```php
public function afterAction($action, $result)
{
    $event = new ActionEvent($action);
    $event->result = $result;
    $this->trigger(self::EVENT_AFTER_ACTION, $event);
    return $event->result;
}
```

- 可见`yii\base\Controller::beforeAction()`方法触发了`self::EVENT_AFTER_ACTION`事件，而触发代码则调用的是父类`yii\base\Component::trigger()`方法，进一步查看`trigger()`方法如下：

```php
public function trigger($name, Event $event = null)
{
    $this->ensureBehaviors();
    if (!empty($this->_events[$name])) {
        if ($event === null) {
            $event = new Event;
        }
        if ($event->sender === null) {
            $event->sender = $this;
        }
        $event->handled = false;
        $event->name = $name;
        foreach ($this->_events[$name] as $handler) {
            $event->data = $handler[1];
            call_user_func($handler[0], $event);
            if ($event->handled) {
                return;
            }
        }
    }
···
    
- 发现组件`yii\base\Component`在触发事件之前实现调用了本类的`ensureBehaviors()`方法，该方法确保定义在了behaviors()中的行为被绑定在了本组件上，继续看`yii\base\Component::ensureBehaviors()`方法：

```php
public function ensureBehaviors()
{
    if ($this->_behaviors === null) {
        $this->_behaviors = [];
        foreach ($this->behaviors() as $name => $behavior) {
            $this->attachBehaviorInternal($name, $behavior);
        }
    }
}
```
- 注意，以上代码中循环了每一个控制器中的`$this->behaviors()`方法返回值。而该类的`attachBehaviorInternal()`方法执行了具体绑定行为，暂时就写到这。
