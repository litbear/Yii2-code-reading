借着这段代码把面向对象的基础知识做个总结。

有继承关系：`yii\web\Application -> yii\base\Application -> yii\base\Module -> yii\di\ServiceLocator -> yii\base\Component -> yii\base\Object`   
`yii\base\Object` 中有：
```php
    public function __construct($config = [])
    {
        if (!empty($config)) {
            Yii::configure($this, $config);
        }
        $this->init();
    }

    public function init()
    {
    }
```
子类`yii\base\Component`中未重写构造方法和`init()`方法

子类`yii\base\Module` 中重写了构造方法和`init()`方法：
```php
    public function __construct($id, $parent = null, $config = [])
    {
        $this->id = $id;
        $this->module = $parent;
        parent::__construct($config);
    }

    public function init()
    {
        if ($this->controllerNamespace === null) {
            $class = get_class($this);
            // 获取当前模块的全限定名，且在全限定名中存在反斜杠时，
            // 把本类的名去掉，换成controllers，拼出命名空间
            if (($pos = strrpos($class, '\\')) !== false) {
                $this->controllerNamespace = substr($class, 0, $pos) . '\\controllers';
            }
        }
    }
```
而在`yii\base\Application` 中有：
```php
    public function __construct($config = [])
    {
        Yii::$app = $this;
        $this->setInstance($this);

        $this->state = self::STATE_BEGIN;

        $this->preInit($config);

        $this->registerErrorHandler($config);

        Component::__construct($config);
    }

    public function init()
    {
        $this->state = self::STATE_INIT;
        $this->bootstrap();
    }
```

问题：
- 子类的构造方法中写了`parent::__construct()`会在内存中产生一个父类实例么？
- 答：不会
- 如果是多重继承的话，写了`parent::__construct()`，会把所有父类的构造方法依次执行么？如果是，次序是怎么样的？
- 答：不会，只会执行直接父类的。
- `Component::__construct($config)`会产生一个`Component`类的实例么？
- 答：不会，只会执行构造方法。
- 这句话对Yii框架的影响是什么？
- `yii\base\Application` 的构造方法有意的跳过了`yii\base\Module::__construct()` 不去执行`module`的构造方法，因为`module`构造方法的参数顺序不同，也就是会执行`Object`的构造方法和`yii\base\Application::init()`。