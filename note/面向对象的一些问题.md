问题：
1, 子类的构造方法中写了parent::__construct()会在内存中产生一个父类实例么？
答：不会
2, 如果是多重继承的话，写了parent::__construct()，会把所有父类的构造方法依次执行么？如果是，次序是怎么样的？
答：不会，只会执行直接父类的。
3, Component::__construct($config)会产生一个Component类的实例么？
答：不会，只会执行构造方法。
4, 这句话对Yii框架的影响是什么？
yii\base\Application 的构造方法有意的跳过了yii\base\Module::__construct() 不去创建module 因为module构造方法的参数顺序不同。
5, 有继承关系：yii\web\Application -> yii\base\Application -> yii\base\Module -> yii\di\ServiceLocator -> yii\base\Component -> yii\base\Object 
yii\base\Object 中有：
    public function __construct($config = [])
    {
        if (!empty($config)) {
            Yii::configure($this, $config);
        }
        $this->init();
    }

    public function init()
    {
    }

子类yii\base\Component 中未重写构造方法和init()方法

子类yii\base\Module 中重写了构造方法和init()方法：
    public function __construct($id, $parent = null, $config = [])
    {
        $this->id = $id;
        $this->module = $parent;
        parent::__construct($config);
    }

    public function init()
    {
        if ($this->controllerNamespace === null) {
            $class = get_class($this);
            // 获取当前模块的全限定名，且在全限定名中存在反斜杠时，
            // 把本类的名去掉，换成controllers，拼出命名空间
            if (($pos = strrpos($class, '\\')) !== false) {
                $this->controllerNamespace = substr($class, 0, $pos) . '\\controllers';
            }
        }
    }

而在yii\base\Application 中有：

    public function __construct($config = [])
    {
        Yii::$app = $this;
        $this->setInstance($this);

        $this->state = self::STATE_BEGIN;

        $this->preInit($config);

        $this->registerErrorHandler($config);

        Component::__construct($config);
    }

    public function init()
    {
        $this->state = self::STATE_INIT;
        $this->bootstrap();
    }