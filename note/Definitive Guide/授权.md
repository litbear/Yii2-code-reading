#授权

授权是指检验用户是否有权限做某件事的过程。`Yii`提供了两种授权方式：权限控制过滤器（ACF）和基于角色的权限控制（RBAC）。

-----------------------------
##权限控制过滤器

权限控制过滤器是一个通过`yii\filters\AccessControl`类来实现的一个简单的权限验证方法。本方法适用于简单的权限控制。顾名思义，权限控制过滤器是一个应用于控制器或模块的动作过滤器。当用户请求执行某动作时，权限控制过滤器会检查访问规则列表以判断用户是否有权访问请求的俄动作。  
以下代码演示了如何在`site`控制器中使用权限控制过滤器：
```php

use yii\web\Controller;
use yii\filters\AccessControl;

class SiteController extends Controller
{
    public function behaviors()
    {
        return [
            'access' => [
                'class' => AccessControl::className(),
                'only' => ['login', 'logout', 'signup'],
                'rules' => [
                    [
                        'allow' => true,
                        'actions' => ['login', 'signup'],
                        'roles' => ['?'],
                    ],
                    [
                        'allow' => true,
                        'actions' => ['logout'],
                        'roles' => ['@'],
                    ],
                ],
            ],
        ];
    }
    // ...
}
```

以上代码中，权限控制过滤器以行为的方式绑定到了`site`控制器中。这是使用权限控制过滤器的典型方法。`only`选项表示，权限控制过滤器只对`login`,`logout'和`signup`动作起作用。所有`site`控制器内其他的动作不受权限控制过滤器的闲置。`rule`选项列出了访问规则，解读如下：

- 允许所有访客（未授权）用户浏览`login`和`signup`两个动作。`role`选项中的问号`?`表示“访客”。
- 允许已授权的用户浏览`logout`，符号`@`是另一个特殊标记，代表“已授权用户”。

权限控制过滤器自上而下逐一检查访问规则，直到找出与当前欲执行动作相匹配的规则。匹配的规则中`allow`的值将会用于判断用户是否被授权。假如没有规则匹配，这就意味着用户没有被授权，权限控制过滤器会停止之后的动作解析。（译者注： only 中没有列出的操作，将无条件获得授权）

当 ACF 判定一个用户没有获得执行当前操作的授权时，它的默认处理是：

- 如果用户是访客，权限控制过滤器会调用`yii\web\User::loginRequired()`将用户重定向到登录页面。
- 假如用户已经登录，就会抛出`yii\web\ForbiddenHttpException`异常。

你可以通过配置 yii\filters\AccessControl::denyCallback 属性定制该行为：
```php
[
    'class' => AccessControl::className(),
    ...
    'denyCallback' => function ($rule, $action) {
        throw new \Exception('You are not allowed to access this page');
    }
]
``` 
访问规则支持很多选项，以下是对支持选项的总结。还可以通过扩展`yii\filters\AccessRule`去创建自己的访问规则类：

- `allow`: 指定该规则是 "允许" 还是 "拒绝" 。（译者注：`true`是允许，`false`是拒绝）。
- `actions`: 指出本规则匹配哪个动作。本选项的值是一个由控制器动作ID组成的数组。匹配比较是大小写敏感的。如果该选项为空，或者不使用该选项， 意味着当前规则适用于所有的动作。
- `controllers`: 指出本规则匹配哪个控制器，本选项的值是由控制器ID组成的数组。每个控制器ID前面都要尽可能加上模块ID前缀。匹配比较是大小写敏感的。如果该选项为空，或者不使用该选项， 意味着当前规则适用于所有的控制器。（译者注：这个选项一般是在控制器的自定义父类中使用才有意义）
- `roles`: 指出本规则适用于哪种角色的用户。框架识别两种用户，它们都是通过`yii\web\User::$isGuest`属性识别的：
    `?`: 匹配游客用户
    `@`: 匹配已登录用户

    使用其他角色名将会触发`yii\web\User::can()`方法。本方法需要开启`RBAC`（在下一节中阐述）。 如果该选项为空或者不使用该选项，意味着该规则适用于所有角色。
- `ips`: 指出本规则适用于哪些客户端IP地址，IP地址可以在末尾包含`*`通配符以匹配相同前缀的IP地址，例如`192.168.*`匹配所有`192.168.`段的地址。如果该选项为空或者不使用该选项，意味着该规则适用于所有IP地址。
- `verbs`: 指出本规则适用于哪些HTTP方法，本规则大小写不敏感。
- `matchCallback`: 指定一个PHP回调函数用于 判定该规则是否满足条件。（译者注：此处的回调函数是匿名函数）
- `denyCallback`: 指定一个PHP回调函数， 当这个规则不满足条件时该函数会被调用。（译者注：此处的回调函数是匿名函数）

以下例子展示了如何使用`matchCallback`选项， 可使你设计任意的访问权限检查逻辑：
```php
use yii\filters\AccessControl;

class SiteController extends Controller
{
    public function behaviors()
    {
        return [
            'access' => [
                'class' => AccessControl::className(),
                'only' => ['special-callback'],
                'rules' => [
                    [
                        'actions' => ['special-callback'],
                        'allow' => true,
                        'matchCallback' => function ($rule, $action) {
                            return date('d-m') === '31-10';
                        }
                    ],
                ],
            ],
        ];
    }

    /**
    *  匹配的回调函数被调用了！这个页面只有每年的10月31号
    *  能访问（译者注：原文在这里说该方法是回调函数不确切，
    *  读者不要和 `matchCallback` 的值即匿名的回调函数混淆理解）。
    */
    public function actionSpecialCallback()
    {
        return $this->render('happy-halloween');
    }
}
```

--------------------------------
##基于角色的权限控制（RBAC）
基于角色的权限控制（RBAC）提供了一个简单而强大的集中访问控制。想要了解跟过关于`RBAC`与其他传统访问控制方案的对比，请参考[维基百科](https://en.wikipedia.org/wiki/Role-based_access_control)。  
Yii实现了一种通用分层的基于角色的权限控制（即上层的角色可以继承下层的所有权限），遵循[NIST RBAC](csrc.nist.gov/rbac/sandhu-ferraiolo-kuhn-00.pdf)模型。他通过`yii\rbac\ManagerInterface` `授权管理组件`提供基于角色的权限控制功能。  
使用`RBAC`包含两个步骤：首先，建立`RBAC`授权数据，第二部，在需要的地方使用授权数据执行访问检查。  
为了方便我们接下来的描述，先介绍`RBAC`的一些基本概念。

###基本概念

角色，是权限的集合（例如发布文章，修改文章等待）。一个角色可以指派给一个或多个用户。要检查一个用户是否有某项权限，可以检查该用户是否分配了某个包含该权限的角色。  
可能会有一个`规则`联系每个角色或权限，规则用一段代码表示，该代码会在判断是否指定的角色或权限适用于当前用户时执行。例如，“修改文章”这个权限可能会有一个检查当前用户是不是文章创建者的规则。在检查权限期间，假如用户不是文章的创建者，那么他将不具备“修改文章”的权限。  
角色和权限都可以按层次进行组织。一个角色可能包含其他角色或权限，一个权限可能包含其他权限。Yii实现了所谓的`偏序`层次结构，包含更多的特殊的`树`层。 一个角色可以包含一个权限，反之则不行。（译者注：可理解为角色在上方，权限在下方，从上到下如果碰到权限那么再往下不能出现角色）。  

###配置`RBAC`

在我们开始定义授权数据和执行访问检查前，需要配置`yii\rbac\ManagerInterface``授权管理组件`。Yii提供了两种`授权管理组件`，分别是`yii\rbac\PhpManager`和`yii\rbac\DbManager`。前者使用PHP脚本文件储存授权数据，后者使用数据库储存授权数据。如果你的应用不需要大量的角色和权限管理，可以使用前者。

####使用`PhpManager`

以下代码演示了使用`yii\rbac\PhpManager`类作为`授权管理组件`的时候，在应用配置文件中如何进行配置：
```php
return [
    // ...
    'components' => [
        'authManager' => [
            'class' => 'yii\rbac\PhpManager',
        ],
        // ...
    ],
];
```

如此配置之后，`授权管理组件`现在可以通过`\Yii::$app->authManager`访问了。  
默认情况下，存放`RBAC`数据的`yii\rbac\PhpManager`类文件放在`@app/rbac`目录下。如果权限层次数据在运行时会被修改，请确认该目录以及该目录下的文件对WEB服务器程序是可写的。  

####使用`DbManager`

以下代码为您示范了使用`yii\rbac\DbManager`类作为`授权管理组件`的时候，在应用配置文件中如何进行配置：

```php
return [
    // ...
    'components' => [
        'authManager' => [
            'class' => 'yii\rbac\DbManager',
        ],
        // ...
    ],
];
```

`DbManager`类使用四张数据库表储存授权数据：

- `yii\rbac\DbManager::$itemTable`: 该表存放授权条目（译者注：即角色和权限）。默认表名为"auth_item"。
- `yii\rbac\DbManager::$itemChildTable`: 该表存放授权条目的层次关系。默认表名为  "auth_item_child"。
- `yii\rbac\DbManager::$assignmentTable`:  该表存放授权条目对用户的分配关系。默认表名为"auth_assignment"。
- `yii\rbac\DbManager::$ruleTable`:  该表存放规则。默认表名为"auth_rule"。

继续之前，你需要在数据库中创建这些表。你可以使用存放在 @yii/rbac/migrations 目录中的数据库迁移文件来做这件事（译者注：根据本人经验，最好是将授权数据初始化命令也写到这个 RBAC 数据库迁移文件中）

    yii migrate --migrationPath=@yii/rbac/migrations

如此配置之后，`授权管理组件`现在可以通过`\Yii::$app->authManager`访问了。  

###构建授权数据

构建授权数据主要包含以下几项任务：

- 定义角色和权限；
- 建立角色和权限之间的关系；
- 定义规则；
- 将规则与角色和权限进行关联；
- 为用户指派角色；
